<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Pedro Villarroel's Webpage</title>
    <!-- Styling -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://ptdrow.github.io/css/styleposts.css" type="text/css" rel="stylesheet">
    <link href="https://ptdrow.github.io/css/style.css" type="text/css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Life+Savers" type="text/css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Dancing+Script" type="text/css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" type="text/css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Iconsolata" type="text/css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <!-- Alternate languages -->
    <link rel="alternate" href="https://ptdrow.github.io/2017/04/19/rhino_python_leva.html" hreflang="es">
    <link rel="alternate" href="https://ptdrow.github.io/2017/04/19/rhino_python_cam_design.html" hreflang="en">
    <!-- Google Analytics -->
    <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-63590859-3', 'auto');
          ga('send', 'pageview');
    </script>
  </head>
  <body>
    <div class="navigation">
      <h1><span class="first">P</span>edro <span class="first">D</span>. <span class="first">V</span>illarroel <span class="first">F</span>.</h1>
      <p>English <a href="rhino_python_leva.html">Espa&ntilde;ol</a><p>
        <ul>
            <li><a id="home" href="https://ptdrow.github.io/indexEN.html">Home</a></li>
            <li class="dropdown">
              <a href="https://ptdrow.github.io/tutorials.html" class="dropbtn">Tutorials</a>
            <!--  <></>   
            <div class="dropdown-content">
              <a id= "pyt" href="#">Python</a>
              <a id= "r" href="#">R</a>
              <a id= "rhino" href="#">Rhinoceros</a>
            </div> -->
            </li>
            <li><a href="#contact">Contact</a></li>
        </ul>
      </div>
    <div class="main">
        <h1>How to draw a cam profile in Rhino with Python</h1>
        <p><span class="first">I</span>n this tutorial i'm going to show you how to use the programming tools of Rhino to create the profile of a cam. These tools are ideal for automating sequential and repetitive drawing processes such as the process of defining cam profiles. Those who do not know the theory to create the cam profile can check this <a href="http://www.codecogs.com/library/engineering/theory_of_machines/cams.php" target="_blank">document</a>.</p>
        <p>For this example I will use the following data:</p>
        <ul><li>Base radius of the cam ( R ): 30mm</li>
            <li>Follower's radius ( r ): 5 mm</li>
            <li>Follower's movement: sinusoidal</li>
            <li>Maximum travel of the follower ( h ) = 15 mm</li></ul>
        <p>First I begin by defining the points by which the center of the follower should pass using a sinusoidal function. The function I want is one that passes through 0mm in height at 0&ordm;, by the maximum height (h) at 180&ordm; and return to 0mm at 360&ordm;, to be continuous at that point.</p>
        <p>A solution might be to use the positive part of the sine function (from 0&ordm; to 180&ordm;) and expand it horizontally to have the same shape but in the range of 0&ordm; to 360&ordm;. With that the profile will pass through the desired points but its derivatives will not be continuous at 360&ordm;, which can generate dynamic problems.</p>
        <img src="images/sinX1.png">
        <p>To solve this, we will use the sine function in the range of -90&ordm; and 270&ordm;, moving it horizontally and vertically to match the points we want. We can do it first by moving 90&ordm; On the horizontal axis (red curve), and then adding one to move it vertically (blue curve). Finally we divide by 2 and multiply by h to obtain the function we are looking for (green curve):</p>
        <img src="images/sinX2.png">
        <p>Now we are going to insert this function in Rhino using Python. To do this we open the script editor in Rhino by clicking on /Tools/PythonScript/Editor and create a new blank script:</p>
        <img src="images/rhino_python1.png">
        <p>The first thing to do is to import the libraries that will be used, which will be rhinoscriptsyntax to be able to use the Rhino commands with Python, and math to calculate our sinusoidal function. Then we write a code that calculates the heights of our sinusoidal function for different degrees in the range of 0 to 360 degrees:</p>
        <div class="code">
            <p><span class="blue">import</span> rhinoscriptsyntax <span class="darkcyan">as</span> rs</p>
            <p><span class="blue">import</span> math</p>
            <br>
            <p class="comment"># Range of degrees from 0 to 360 by delta</p>
            <p>delta = <span class="indigo">15</span></p>
            <p>degrees = <span class="midnightblue">range</span>(<span class="indigo">0</span>,<span class="indigo">360</span>+delta,delta)</p>
            <br>
            <p class="comment"># Create a sin function that goes from 0 to h</p>
            <p class="comment"># in the interval of 0 to 180 degrees and goes back to 0 from 180 to 360.</p>
            <p>h = <span class="indigo">15</span></p>
            <p>L = []</p>
            <br>
            <p><span class="blue">for</span> alpha <span class="blue">in</span> <span class="midnightblue">range</span>(-<span class="indigo">90</span>,<span class="indigo">270</span>+delta,delta): <span class="comment">#Translates the sin function horizontally</span></p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;radian_alpha = alpha * math.pi / <span class="indigo">180</span></p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;L.<span class="midnightblue">append(</span>(<span class="midnightblue">round</span>(math.<span class="midnightblue">sin</span>(radian_alpha),<span class="indigo">4</span>) + <span class="indigo">1</span> )* h/<span class="indigo">2</span>) <span class="comment"># Adjust the sin function vertically</span></p>
        </div>
        <p>In this tutorial I will draw many additional elements to the cam profile just to illustrate graphically the profile drawing process. In the end they can be deleted in the Rhino viewport as well as in the Python script. For this you have to know the id of each element that you want to delete so I recommend to keep them in lists.</p>
        <p>I add to the script the variables for the motion of the cam we defined above. I will also create some empty lists for saving values and drawing elements. Later on we will see what each one does in the script:</p>
        <div class="code">
            <p class="comment"># Base radius of the cam</p>
            <p>R = <span class="indigo">30</span></p>
            <br>
            <p class="comment"># Radius of the follower</p>
            <p>r = <span class="indigo">5</span></p>
            <br>
            <p class="comment"># Rotation center of the cam</p>
            <p>p_zero = (<span class="indigo">0</span>,<span class="indigo">0</span>,<span class="indigo">0</span>)</p>
            <br>
            <p class="comment"># Drawing colors</p>
            <p>red =(<span class="indigo">255</span>,<span class="indigo">0</span>,<span class="indigo">0</span>)</p>
            <p>blue = (<span class="indigo">0</span>,<span class="indigo">0</span>,<span class="indigo">255</span>)</p>
            <p>magenta = (<span class="indigo">255</span>,<span class="indigo">0</span>,<span class="indigo">255</span>)</p>
            <p>yellow = (<span class="indigo">255</span>,<span class="indigo">255</span>,<span class="indigo">0</span>)</p>
            <p>green = (<span class="indigo">0</span>,<span class="indigo">255</span>,<span class="indigo">0</span>)</p>
            <br>
            <p class="comment"># Lists of points and lines</p>
            <p>points = []</p>
            <p>profile_line = []</p>
            <p>radial_line = []</p>
            <p>tangent_points =[]</p>
        </div>
        <p>With these values we can draw the position of the follower for each angle with respect to the cam. The process I use is as follows:</p>
        <ul><li>Create a "for" cycle that goes over the range of degrees.</li>
            <li>Draw a line from the center of rotation to the center of the follower in each angle. To do this I use the Polar function, entering the center of the cam (p_zero), the angle (degree), and the distance from center to center, which is the sum of the base radius of the cam, the radius of the follower And the height of the sinusoidal function for each angle.</li>
            <li>Save the position of the center of the follower for drawing its movement around the wheel later.</li>
            <li>Draw the follower for each position</li>
            <li>Assume the point of contact between the follower and the cam is the intersection of the follower and the radius of the cam.</li>
        </ul>        
        <div class="code">
            <p>rs.<span class="midnightblue">AddCircle</span>(p_zero,R)</p>
            <br>
            <p class="comment"># Draw lines and circles for each degree with the corresponding length</p>
            <p><span class="blue">for</span> (i,degree) <span class="blue">in</span> <span class="midnightblue">enumerate</span>(degrees[:-<span class="indigo">1</span>]):</p>
            <br>
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;# Draw a line from the rotation center to the position of the follower</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;p_end = rs.<span class="midnightblue">Polar</span>(p_zero, degree,R+r+L[i])</p><p>&nbsp;&nbsp;&nbsp;&nbsp;radial_line.<span class="midnightblue">append</span>(rs.<span class="midnightblue">AddLine</span>(p_zero,p_end))</p>
            <br>
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;# Save the position of the follower's center for drawing the motion of it</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;points.<span class="midnightblue">append</span>(p_end)</p>
            <br>
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;#Draw the follower</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;circle = rs.<span class="midnightblue">AddCircle</span>(p_end,r)</p>
        </div>
        <p>The contact point between the cam and the follower is initially assumed as it is very difficult to know a priori where it is located. At first one supposes that this point is in the line that links the centers of the cam and the follower, but in practice this is not true for every degree. Depending on the size of the follower, the slopes and complexity of the movement of the follower relative to the cam, this point of contact can move slightly to one side or the other. Many times this difference is very small and can be accepted within the design, understanding that the movement of the follower will be slightly distant from the theoretical movement to which it is designed, not being serious especially because in the most important points of the The cam (maximum and minimum) the point of contact usually coincides with the intersection of the radius with the circumference of the follower. In other applications where the precision of this movement is of greater importance, for example, where it is critical to have well-engineered and controlled system forces, this assumption can be not good enough.</p>
        <p>Let's draw the cam as it turns out if we assume that the point of contact is always on the line that links the centers.</p>
        <div class="code">
            <p class="comment"># Draw the curve of the motion of the follower</p>
            <p>points.<span class="midnightblue">append</span>(points[<span class="indigo">0</span>])</p>
            <p>rs.<span class="midnightblue">AddInterpCurve</span>(points, degree=<span class="indigo">3</span>, knotstyle=<span class="indigo">3</span>)</p>
            <br>
            <p class="comment"># Draw the curve of the original supposed contact points to show the difference</p>
            <p>tangent_points.<span class="midnightblue">append</span>(tangent_points[<span class="indigo">0</span>])</p>
            <p>rs.<span class="midnightblue">ObjectColor</span>(rs.<span class="midnightblue">AddInterpCurve</span>(tangent_points, degree=<span class="indigo">3</span>, knotstyle=<span class="indigo">3</span>),yellow)</p>
        </div>
        <img src="images/rhino_python2.png">
        <p>The image shows the optional construction lines in black and the preliminary cam in yellow. Let's zoom in to see how it is ending up the contact between the cam and follower:</p>
        <img src="images/rhino_python3.png">
        <p>As we see in the zoom of the image for certain positions the resulting cam profile is not tangent to the profile of the follower, but cuts it, which causes that in those positions the cam will be slightly above the expected theoretical position . As I mentioned earlier this may or may not be a problem depending on the application.</p>
        <p>Next I will do some calculations to improve the estimation of the contact point and obtain a better profile.</p>
        <p>We know that at the point of contact between two tangent curves, the tangent lines to each curve passing through that point are equal. In this case the curves will be the profile of the follower, which I know for each angle, but I do not know its point of contact, and the profile of the cam for which I have an initial assumption that makes relatively small errors but Inadmissible for a given application.</p>
        <p>We can suppose that the cam is a polynomial of infinite sides of infinitesimal length, which unite the point of contact between the cam and the follower in an instant, with the point of contact in a moment, and so on. Until completing the profile. Now, if instead of thinking of infinite sides, we think of a finite number of sides equal to the number of partitions of the circumference that we did initially, we will obtain a polygonal cam.</p>
        <p>To draw a polygonal cam I'm going to use the same for loop with which I'm calculating the points of the follower's movement and add code to draw a straight line between two consecutive points. By the way the cycle is executed I will need to pre-calculate in each angle the point of contact of the next angle. The following code shows the extra lines that will be added to the for cycle:</p>
        <div class="code">
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;#Calc the contact point of the next follower position</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;p_tangent_next = rs.<span class="midnightblue">Polar</span>(p_zero, degrees[i+<span class="indigo">1</span>],R+L[i+<span class="indigo">1</span>])</p>
            <br>
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;# Draw lines connecting the supposed contact points (profile_line)</p><p>&nbsp;&nbsp;&nbsp;&nbsp;profile_line.<span class="midnightblue">append</span>(rs.<span class="midnightblue">AddLine</span>(p_tangent,p_tangent_next))</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;rs.<span class="midnightblue">ObjectColor</span>(profile_line[i], color=red)</p>
        </div>
        <p>In each position we can draw a tangent to the follower that is perpendicular to the radius of the cam. While we can not draw at this point a tangent to the polygonal profile of the cam, we can take the adjacent sides as a reference to a so-called tangent. In other words, the assumed tangent to the cam passing through that point must have equal angles with both adjacent sides. Then the problem translates to looking at what point of the follower's circumference a tangent is generated that is equal to the assumed tangent, or what is the same, that maintains equal angles with the anterior and posterior sides of the traverse. I am going to add the following code to draw the follower tangents perpendicular to the radius of the cam:</p>
        <div class="code">
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;# Draw tangent lines at the supposed contact points </p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;p_end = rs.<span class="midnightblue">Polar</span>(p_tangent, degree+<span class="indigo">90</span>,<span class="indigo">10</span>)</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;rs.<span class="midnightblue">ObjectColor</span>(rs.<span class="midnightblue">AddLine</span>(p_tangent,p_end),blue)</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;p_end = rs.<span class="midnightblue">Polar</span>(p_tangent, degree-<span class="indigo">90</span>,<span class="indigo">10</span>)</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;rs.<span class="midnightblue">ObjectColor</span>(rs.<span class="midnightblue">AddLine</span>(p_tangent,p_end),blue)</p>
        </div>
        <p>Running the script we get the new lines of the polygon (red) and tangents (blue). The following image is a zoom around one of the follower-follower contact points:</p>
        <img src="images/rhino_python4.png">
        <p>As we see in the image both sides (anterior and posterior) of the polygonal at that point form an angle with the tangent of the circle.</p>
        <img src="images/cam_angles.png">
        <p> The picture shows the &alpha; and &beta; angles, which are the ones we can easily measure with the Rhino functions; &alpha;' and &beta;' angles, which are the ones that form the polygonals with the tangent to the follower and we want them to be equals(&alpha;'' and &beta;''), for which we rotate the tangent to a &gamma; angle. The angle &gamma;, which indicates how rotated is the contact point on the circumference of the follower, is given by:</p>
        <img src="images/angle_equations.png">
        <p>However, every time we change the position of the contact point, the orientations of the polygonals will also be modified slightly, so the new solution will not be accurate either. However it will be much more precise that the original assumption and in case of needing greater precision can be iterated until the errors converge to an acceptable error. For our case with one iteration will be enough.</p>
        <p>Now I will add code to calculate &gamma; from &alpha; and &beta;, and find the new contact point with the Polar function:</p>
        <div class="code">
            <p class="comment"># Calculate a new supposed contact points</p>
            <p>points = []</p>
            <br>
            <p><span class="blue">for</span> i <span class="blue">in</span> <span class="midnightblue">xrange</span>(<span class="midnightblue">len</span>(degrees)-<span class="indigo">1</span>]):</p>
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;# Calculate the difference(angle) between the radial lines and profile lines</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;alpha = rs.<span class="midnightblue">Angle2</span>(radial_line[i],profile_line[i])[<span class="indigo">0</span>]</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;beta = rs.<span class="midnightblue">Angle2</span>(radial_line[i],profile_line[i-<span class="indigo">1</span>])[<span class="indigo">0</span>]</p>
            <br>
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;# Calculate the angle were the new contact point is suppossed to be</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;gamma = <span class="indigo">90</span> - (alpha+beta)/<span class="indigo">2</span></p>
            <br>
            <p class="comment">&nbsp;&nbsp;&nbsp;&nbsp;# Draw a line and store the end point (new supposed contact point)</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;p_start = rs.<span class="midnightblue">Polar</span>(p_zero, degrees[i],R+L[i]+r)</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;p_end = rs.<span class="midnightblue">Polar</span>(p_start, degrees[i]+<span class="indigo">180</span>-gamma,r)</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;rs.<span class="midnightblue">ObjectColor</span>(rs.<span class="midnightblue">AddLine</span>(p_start,p_end), color=green)</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;points.<span class="midnightblue">append</span>(p_end)</p>
        </div>
        <p>Lastly, we draw the new profile:</p>
        <div class="code">
            <p class="comment"># Draw the curve of the cam (interpolating through the suppossed contact points)</p>
            <p>points.<span class="midnightblue">append</span>(points[<span class="indigo">0</span>])</p>
            <p>rs.<span class="midnightblue">ObjectColor</span>(rs.<span class="midnightblue">AddInterpCurve</span>(points, degree=<span class="indigo">3</span>, knotstyle=<span class="indigo">3</span>),magenta)</p>
        </div>
        <img src="images/rhino_python5.png">
        <p>As we see in the image the new curve (magenta) is now much better than the first one (yellow). This new curve no longer cuts the profile of the follower (at least not in an appreciable way), as does the yellow curve. If it is not good enough it can be iterated once more, but now using the new points of contact as the points that define the polygon.</p>
        <p>Now we have the <a href="camtutorial.py"> code that draws the cam </a> ready, if you want remove the code that draws construction elements to get the profile of the cam, and modify the input variables to get other cams.</p>
		<script>
		var disqus_config = function () {
		this.page.url = 'https://ptdrow.github.io/2017/04/19/rhino_python_cam_design.html';
		this.page.identifier = 'RhinoPythonCamDesign';
		};
		(function() { // DON'T EDIT BELOW THIS LINE
		var d = document, s = d.createElement('script');
		s.src = 'https://ptdrow.disqus.com/embed.js';
		s.setAttribute('data-timestamp', +new Date());
		(d.head || d.body).appendChild(s);
		})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
    <h1 id="contact">Contact</h1>
    <div class="foot">
        <a id= "facebook" href="https://www.facebook.com/ptdrow" target="_blank"><img src="https://ptdrow.github.io/images/facebookMed.png"></a>
        <a id= "strava" href="https://www.strava.com/athletes/ptdrow" target="_blank"><img src="https://ptdrow.github.io/images/stravaMed.png"></a>
        <a id= "instagram" href="https://www.instagram.com/ptdrow/" target="_blank"><img src="https://ptdrow.github.io/images/instaMed.png"></a>
        <a id= "twitter" href="https://twitter.com/pedrodvf" target="_blank"><img src="https://ptdrow.github.io/images/twitterMed.png"></a>
    </div>
    <div class="copy">
        <p>&copy; 2017 Pedro Villarroel</p>
    </div>
  </body>
</html>
<!--  <></>   -->
